name: CI/CD Pipeline for FastAPI on AWS EKS

# Trigger the workflow on pushes to the 'main' branch
on:
  push:
    branches:
      - main

# Set permissions for the job, crucial for OIDC authentication
permissions:
  id-token: write
  contents: read

env:
  # Environment variables accessible to all steps in the job
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.AWS_ECR_REPOSITORY }}
  EKS_CLUSTER_NAME: ${{ secrets.AWS_EKS_CLUSTER_NAME }}
  
jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Configure AWS credentials using OIDC for secure access
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          # The following line is crucial for EKS to configure kubectl
          eks-cluster-name: ${{ env.EKS_CLUSTER_NAME }} 

      # Step 3: Log in to AWS ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Step 4: Build, tag, and push the Docker image to ECR
      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # Step 5: Clean up old Docker images in ECR, keeping the latest 3
      - name: ECR image cleanup
        run: |
          # Get list of image digests, sorted by push date
          image_digests=$(aws ecr describe-images --repository-name $ECR_REPOSITORY \
            --query 'sort_by(imageDetails,& imagePushedAt)[].imageDigest' --output text)

          # Check if there are more than 3 images
          num_images=$(echo $image_digests | wc -w)
          if [ $num_images -gt 3 ]; then
            digests_to_delete=$(echo $image_digests | cut -d' ' -f4-)
            echo "Deleting old images with digests: $digests_to_delete"
            aws ecr batch-delete-image --repository-name $ECR_REPOSITORY --image-ids imageDigest=$digests_to_delete || true
          else
            echo "Less than 4 images, no cleanup needed."
          fi
      
      # step 6 configure kubectl
      - name: Configure Kubernetes client
        uses: silverlyra/setup-aws-eks@v0.1
        with:
          cluster: ${{ env.EKS_CLUSTER_NAME }}

      # Step 7: Create/Update the Kubernetes secret for API keys
      # The --dry-run=client -o yaml pipes the output to kubectl apply,
      # making this command idempotent (safe to run multiple times).
      - name: Create or update Kubernetes secret
        run: |
          kubectl create secret generic fastapi-secrets --from-literal=GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }} --dry-run=client -o yaml | kubectl apply -f -
      
      # Step 8: Deploy the application to EKS
      - name: Deploy to EKS
        run: |
          # Use 'sed' to update the deployment file with the new image tag
          sed -i "s|<your-ecr-repo-name>:latest|$ECR_REPOSITORY:latest|g" deployment.yaml
          
          # Apply the changes to the Kubernetes cluster
          kubectl apply -f deployment.yaml